import java.nio.file.Files
import java.nio.file.Paths
import java.util.regex.Pattern

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'maven-publish'
apply plugin: 'com.adarshr.test-logger'

// ===========================================================================
// plugin info
// ===========================================================================
group                      'co.elastic.logstash.plugins.filter.elasticintegration' // must match the package of the main plugin class
version                    "${file("VERSION").text.trim()}" // read from required VERSION file
description                = "Elastic Integration filter"
// ===========================================================================

java {
    sourceCompatibility = 17
    targetCompatibility = 17
}
tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

buildscript {
    repositories {
        mavenCentral()
        maven {
          url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath "gradle.plugin.com.github.johnrengelman:shadow:7.1.2"
        classpath 'com.adarshr:gradle-test-logger-plugin:3.2.0'
    }
}

repositories {
    mavenCentral()
}

configurations {
    elasticsearch
    implementation.extendsFrom elasticsearch
}

wrapper {
    gradleVersion = '7.5.1'
    distributionUrl = distributionUrl.replace("bin", "all")
}

apply plugin: 'com.github.johnrengelman.shadow'
shadowJar {
    classifier = null
    zip64 true
}

dependencies {
    implementation 'co.elastic.clients:elasticsearch-java:8.6.1'

    implementation 'org.apache.logging.log4j:log4j-api:2.19.0'
    implementation 'org.apache.logging.log4j:log4j-core:2.19.0'

    elasticsearch fileTree(dir: 'local_libs', include: ["*.jar"])
    implementation fileTree(dir: LOGSTASH_CORE_PATH, include: "build/libs/logstash-core.jar")

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.1.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.1.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.1.1'
    testImplementation 'org.hamcrest:hamcrest-library:2.2'

    testImplementation 'org.jruby:jruby-complete:9.3.9.0'
}

/**
 * @param packageNameSpec e.g., "package-name" or "nesting/path/package-name"
 * @return a {@code Closure<Boolean>} determines if the provided {@code FileTreeElement}
 *         is a package matching the {@code packageNameSpec} or a nesting that _could_ include it.
 */
def jarPackageNamed(String packageNameSpec) {
    def packageNamePath = Paths.get(packageNameSpec)
    def packageName = packageNamePath.fileName.toString()
    def packageNesting = packageNamePath.parent
    def packagePattern = namedPackageWithAnyVersionPattern(packageName, "jar")

    return { FileTreeElement element ->
        if (packageNesting != null && packageNesting.startsWith(element.relativePath.toString())) { return true }
        if (packageNesting == null && element.relativePath.toString() != element.name) { return false }

        return element.name.matches(packagePattern)
    }
}

def namedPackageWithAnyVersionPattern(String packageName, String suffix = null) {
    def escapedPackagePart = Pattern.quote(packageName)
    def optionalAnyVersionPart = "(?:-\\d+(?:\\.\\d+)*(?i:-SNAPSHOT(?:-[0-9A-F]+)?)?)?"
    def escapedSuffixPart = suffix == null ? "" : Pattern.quote(".${suffix}")
    return Pattern.compile("${escapedPackagePart}${optionalAnyVersionPart}${escapedSuffixPart}");
}

task findElasticsearchLocalDistro() {
    if (!project.hasProperty("ELASTICSEARCH_LOCALDISTRO")) {
        throw new StopActionException(""""
            The property ELASTICSEARCH_LOCALDISTRO must be defined, and should point to an Elasticsearch localDistro build
            (e.g., the `build/distribution/local` generated by performing `./gradlew localDistro` in a local checkout of Elasticsearch)
        """)
    }

    def buildDestination = file("${ELASTICSEARCH_LOCALDISTRO}/")
    if (!buildDestination.exists()) { throw new StopActionException("ELASTICSEARCH_LOCALDISTRO(${ELASTICSEARCH_LOCALDISTRO}) does not exist") }

    def buildLocationCandidates = buildDestination.listFiles({ it.isDirectory() && it.name.matches(namedPackageWithAnyVersionPattern("elasticsearch")) } as FileFilter)
    if (buildLocationCandidates.length == 0) { throw new StopActionException("No local ES build in ${buildDestination.toPath()}") }
    if (buildLocationCandidates.length > 1) { throw new StopActionException("Multiple local ES builds in ${buildDestination.toPath()}")}

    ext.build_location = buildLocationCandidates.first()
}

task importMinimalElasticsearch(type: Copy) {
    def elasticsearchBuildTree = findElasticsearchLocalDistro.ext.build_location

    from("${elasticsearchBuildTree}/lib/") {
        include jarPackageNamed("elasticsearch")
        include jarPackageNamed("elasticsearch-core")
        include jarPackageNamed("elasticsearch-x-content")
        include jarPackageNamed("lucene-core")
    }

    from("${elasticsearchBuildTree}/modules/ingest-common") {
        include jarPackageNamed("ingest-common")
        include jarPackageNamed("elasticsearch-grok")
        include jarPackageNamed("elasticsearch-dissect")
        include jarPackageNamed("elasticsearch-grok")
    }

    from("${elasticsearchBuildTree}/modules/ingest-user-agent") {
        include jarPackageNamed("ingest-user-agent")
    }

    from("${elasticsearchBuildTree}/modules/lang-mustache") {
        include jarPackageNamed("lang-mustache")
        include jarPackageNamed("compiler")
    }

    from("${elasticsearchBuildTree}/modules/lang-painless") {
        include jarPackageNamed("lang-painless")
        include jarPackageNamed("antlr4-runtime")
        include jarPackageNamed("asm-util")
        include jarPackageNamed("asm-commons")
        include jarPackageNamed("asm-tree")
        include jarPackageNamed("asm")
        include jarPackageNamed("spi/elasticsearch-scripting-painless-spi")
    }

    into 'local_libs'

    includeEmptyDirs(false)
    eachFile { path = name } // flatten
    eachFile { logger.debug "copying ${it} to local_libs" }
}
compileJava.dependsOn(importMinimalElasticsearch)
shadowJar.dependsOn(importMinimalElasticsearch)

clean {
    delete "${projectDir}/vendor/"
    delete "${projectDir}/local_libs/"
    delete "${projectDir}/*.gem"
    delete "${projectDir}/lib/logstash/filters/elastic_integration/jar_dependencies.rb"
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

task generateGemJarRequiresFile {

    File jars_file = file("${projectDir}/lib/logstash/filters/elastic_integration/jar_dependencies.rb")
    outputs.file(jars_file)
    inputs.files(tasks.assemble)

    doLast {
        jars_file.parentFile.mkdirs()
        jars_file.newWriter().withWriter { w ->
            w << "# AUTOGENERATED BY THE GRADLE SCRIPT. DO NOT EDIT.\n\n"
            w << "require \'jar_dependencies\'\n"
            w << "require_jar(\'${project.group}\', \'${project.name}\', \'${project.version}\')\n"
        }
    }
}

test {
    useJUnitPlatform()
}

tasks.withType(Test) {
    // Add Exports to enable tests to run in JDK17
    jvmArgs = [
            "--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
            "--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
            "--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
            "--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
            "--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
            "--add-opens=java.base/java.lang=ALL-UNNAMED",
            "--add-opens=java.base/java.util=ALL-UNNAMED"
    ]
}

task vendor(dependsOn: shadowJar) {
    doLast {
        String vendorPathPrefix = "vendor/jar-dependencies"
        String projectGroupPath = project.group.replaceAll('\\.', '/')
        File projectJarFile = file("${vendorPathPrefix}/${projectGroupPath}/logstash-filter-elastic_integration/${project.version}/logstash-filter-elastic_integration-${project.version}.jar")
        projectJarFile.mkdirs()
        Files.copy(file("$buildDir/libs/${project.name}-${project.version}.jar").toPath(), projectJarFile.toPath(), REPLACE_EXISTING)
    }
}
vendor.dependsOn(shadowJar, generateGemJarRequiresFile)

task generateRubySupportFiles() {
    doLast {
        generateRubySupportFilesForPlugin(project.description, project.group, version)
    }
}

task removeObsoleteJars() {
    doLast {
        new FileNameFinder().getFileNames(
                projectDir.toString(),
                "vendor/**/" + pluginInfo.pluginFullName() + "*.jar",
                "vendor/**/" + pluginInfo.pluginFullName() + "-" + version + ".jar").each { f ->
            delete f
        }
    }
}
